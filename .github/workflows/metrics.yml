name: metrics

on:
  schedule:
    - cron: "0 0 * * *"
  push:
    branches:
      - main
      - master
    paths-ignore:
      - "assets/metrics.svg"
      - "assets/highlights.svg"
  workflow_dispatch:
  repository_dispatch:
    types:
      - metrics_update

permissions:
  contents: write

concurrency:
  group: metrics-${{ github.ref }}
  cancel-in-progress: true

jobs:
  github-metrics:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Generate metrics
        uses: lowlighter/metrics@latest
        with:
          filename: assets/metrics.svg
          token: ${{ secrets.METRICS_TOKEN }}

          user: blueokanna
          template: classic
          base: header, community, repositories
          base_indepth: yes

          repositories_affiliations: owner
          repositories_forks: no
          repositories: 200
          repositories_batch: 50

          config_timezone: Asia/Shanghai
          config_display: large

          plugin_languages: yes
          plugin_languages_details: bytes-size, percentage
          plugin_languages_limit: 5
          plugin_languages_other: yes

          plugin_isocalendar: yes
          plugin_isocalendar_duration: half-year

      - name: Generate highlights (top starred/forked/active)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.METRICS_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const login = 'blueokanna';
            const perPage = 100;

            async function fetchAllRepos() {
              let after = null;
              const repos = [];
              while (true) {
                const query = `
                  query($login: String!, $perPage: Int!, $after: String) {
                    user(login: $login) {
                      repositories(first: $perPage, after: $after, ownerAffiliations: OWNER, isFork: false, orderBy: {field: PUSHED_AT, direction: DESC}) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          name
                          description
                          url
                          stargazerCount
                          forkCount
                          pushedAt
                          isArchived
                          isTemplate
                        }
                      }
                    }
                  }
                `;
                const res = await github.graphql(query, { login, perPage, after });
                const page = res.user.repositories.nodes || [];
                repos.push(...page);
                const { hasNextPage, endCursor } = res.user.repositories.pageInfo;
                if (!hasNextPage) break;
                after = endCursor;
              }
              return repos;
            }

            function pickTop(repos, key) {
              return repos.reduce((best, r) => {
                if (!best) return r;
                if ((r[key] ?? 0) > (best[key] ?? 0)) return r;
                return best;
              }, null);
            }

            function escapeXml(s) {
              return String(s ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
            }

            function fmtRepoLine(label, r) {
              if (!r) return `${label}: (no data)`;
              const name = `${login}/${r.name}`;
              const stars = r.stargazerCount ?? 0;
              const forks = r.forkCount ?? 0;
              const pushed = r.pushedAt ? new Date(r.pushedAt).toISOString().slice(0, 10) : 'n/a';
              return `${label}: ${name}  ★${stars}  ⑂${forks}  push:${pushed}`;
            }

            const repos = await fetchAllRepos();
            const active = repos[0] || null;
            const topStarred = pickTop(repos, 'stargazerCount');
            const topForked = pickTop(repos, 'forkCount');

            const lines = [
              'SYSTEM:: repo highlights (live)',
              fmtRepoLine('TOP_STARRED', topStarred),
              fmtRepoLine('TOP_FORKED ', topForked),
              fmtRepoLine('MOST_ACTIVE', active),
            ];

            const width = 960;
            const height = 190;
            const padX = 28;
            const startY = 54;
            const lineH = 28;
            const svg = `<?xml version="1.0" encoding="UTF-8"?>
            <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
              <defs>
                <linearGradient id="g" x1="0" y1="0" x2="1" y2="0">
                  <stop offset="0" stop-color="#22d3ee" stop-opacity="0.9" />
                  <stop offset="1" stop-color="#a78bfa" stop-opacity="0.9" />
                </linearGradient>
                <filter id="s" x="-20%" y="-20%" width="140%" height="140%">
                  <feDropShadow dx="0" dy="0" stdDeviation="6" flood-color="#000" flood-opacity="0.35" />
                </filter>
              </defs>
              <rect x="14" y="14" width="${width - 28}" height="${height - 28}" rx="14" fill="#0d1117" stroke="url(#g)" stroke-width="1.6" filter="url(#s)" />
              <text x="${padX}" y="38" fill="#22d3ee" font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace" font-size="16" font-weight="700">$ cat highlights.txt</text>
              ${lines.map((t, i) => {
                const y = startY + i * lineH;
                const color = i === 0 ? '#c9d1d9' : '#9ca3af';
                return `<text x="${padX}" y="${y}" fill="${color}" font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace" font-size="14">${escapeXml(t)}</text>`;
              }).join('\n')}
            </svg>`;

            const outPath = path.join(process.env.GITHUB_WORKSPACE || '.', 'assets', 'highlights.svg');
            fs.mkdirSync(path.dirname(outPath), { recursive: true });
            fs.writeFileSync(outPath, svg, 'utf8');

            // Commit via Contents API so it works without checkout
            const contentB64 = Buffer.from(svg, 'utf8').toString('base64');
            let sha;
            try {
              const existing = await github.rest.repos.getContent({ owner, repo, path: 'assets/highlights.svg' });
              sha = existing.data.sha;
            } catch (e) {
              sha = undefined;
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: 'assets/highlights.svg',
              message: 'chore: update highlights.svg',
              content: contentB64,
              sha,
            });
